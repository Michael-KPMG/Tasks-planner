Creating an Organized SCSS File Structure Using Modern Practices

frontend
Table of Contents
Understanding Modern SCSS
The Modern 7-1 Pattern
Modern File Structure
The Index Files
The Main File
Using Namespaces
Best Practices for Modern SCSS
Migration Tips
Performance Considerations
Conclusion
As a frontend developer, maintaining a clean and organized SCSS file structure is crucial for scalable and manageable styling. While SCSS (Sassy CSS) has evolved, so have the best practices for organizing your files. This guide focuses on modern SCSS practices using @use and @forward instead of the deprecated @import.

Understanding Modern SCSS
Before diving into structure, let's understand the key modern SCSS features:

@use loads mixins, functions, and variables from other stylesheets and provides an explicit namespace
@forward makes the public members of another module available to stylesheets that use your module
Members are private by default and must be marked with !default to be configurable
The Modern 7-1 Pattern
The 7-1 pattern remains a solid approach but needs adaptation for modern SCSS. It consists of seven folders plus one main file, with each folder containing an index file to manage its members.

Folder Structure
Abstracts: Global SCSS tools and helpers

Variables
Functions
Mixins
Placeholders
Components: Individual UI components

Buttons
Forms
Cards
Navigation
Layout: Major layout sections

Header
Footer
Grid system
Navigation layouts
Pages: Page-specific styles

Home
About
Contact
Themes: Visual themes

Light theme
Dark theme
Brand variations
Base: Global HTML element styles

Reset/Normalize
Typography
Base elements
Vendors: Third-party styles

Bootstrap
Select2
Datepicker
Optional:

States: State-specific styles
Active states
Loading states
Error states
Modern File Structure
scss/
├── abstracts/
│   ├── _index.scss        // Forwards all abstract members
│   ├── _functions.scss
│   ├── _mixins.scss
│   └── _variables.scss
├── base/
│   ├── _index.scss
│   ├── _reset.scss
│   └── _typography.scss
// ... (other folders follow same pattern)
└── main.scss
The Index Files
Each folder should have an _index.scss file that forwards its members. Here's how they should look:

// abstracts/_index.scss
@forward 'variables';
@forward 'functions';
@forward 'mixins';

// components/_index.scss
@forward 'button';
@forward 'form';
@forward 'card';
The Main File
The main file now uses @use instead of @import:

// main.scss
@use 'abstracts' as *;         // Global access to variables/mixins
@use 'vendors' as vendors;     // Namespaced access
@use 'base' as base;
@use 'components' as comp;
@use 'layout' as layout;
@use 'pages' as pages;
@use 'themes' as themes;
Using Namespaces
Modern SCSS requires explicit namespacing. Here's how to use them:

// Using namespaced members
.button {
  // From abstracts (global)
  background-color: $primary-color;

  // From components
  @include comp.button-base;

  // From vendors
  @include vendors.bootstrap-spacing;
}
Best Practices for Modern SCSS
Use Index Files Effectively
Keep index files clean and focused
Use @forward with show or hide to control member visibility
   @forward 'variables' show $primary-color, $secondary-color;
Configure Defaults
Mark configurable variables with !default
Use configuration files when needed
   // _variables.scss
   $primary-color: blue !default;
Namespace Management

Use as * sparingly (primarily for abstracts)
Choose clear, consistent namespace aliases
Document namespace conventions in your styleguide
Module Organization

One component per file
Use clear, consistent naming
Keep dependencies explicit
Documentation

Comment your configurations
Document your module's public API
Include usage examples
Migration Tips
When moving from @import to @use/@forward:

Start with your abstracts folder
Update one folder at a time
Test thoroughly between updates
Update dependent files as needed
Don't mix @import with @use/@forward in the same file
Performance Considerations
Modern SCSS module system provides several performance benefits:

Modules are only executed once
Dead code elimination is more effective
Better dependency tracking
Clearer dependency graph
Conclusion
Modern SCSS file structure emphasizes clarity, maintainability, and explicit dependencies. By using @use and @forward, you create a more robust and maintainable stylesheet architecture. This approach scales well with your project while providing better encapsulation and clearer dependencies.

Remember to:

Use explicit namespacing
Maintain clear folder structure
Keep your index files organized
Document your module system
Follow consistent naming conventions
With these modern practices in place, your SCSS will be more maintainable, scalable, and easier for teams to work with.

Building a Scalable CSS Architecture With BEM and Utility Classes

Sebastiano Guerriero on Oct 21, 2021
Get affordable and hassle-free WordPress hosting plans with Cloudways — start your free trial today.

Maintaining a large-scale CSS project is hard. Over the years, we’ve witnessed different approaches aimed at easing the process of writing scalable CSS. In the end, we all try to meet the following two goals:

Efficiency: we want to reduce the time spent thinking about how things should be done and increase the time doing things.
Consistency: we want to make sure all developers are on the same page.
For the past year and a half, I’ve been working on a component library and a front-end framework called CodyFrame. We currently have 220+ components. These components are not isolated modules: they’re reusable patterns, often merged into each other to create complex templates.

The challenges of this project have forced our team to develop a way of building scalable CSS architectures. This method relies on CSS globals, BEM, and utility classes.

I’m happy to share it! 👇

CSS Globals in 30 seconds
Globals are CSS files containing rules that apply crosswise to all components (e.g., spacing scale, typography scale, colors, etc.). Globals use tokens to keep the design consistent across all components and reduce the size of their CSS.

Here’s an example of typography global rules:

/* Typography | Global */
:root {
  /* body font size */
  --text-base-size: 1em;


  /* type scale */
  --text-scale-ratio: 1.2;
  --text-xs: calc((--text-base-size / var(--text-scale-ratio)) / var(--text-scale-ratio));
  --text-sm: calc(var(--text-xs) * var(--text-scale-ratio));
  --text-md: calc(var(--text-sm) * var(--text-scale-ratio) * var(--text-scale-ratio));
  --text-lg: calc(var(--text-md) * var(--text-scale-ratio));
  --text-xl: calc(var(--text-lg) * var(--text-scale-ratio));
  --text-xxl: calc(var(--text-xl) * var(--text-scale-ratio));
}


@media (min-width: 64rem) { /* responsive decision applied to all text elements */
  :root {
    --text-base-size: 1.25em;
    --text-scale-ratio: 1.25;
  }
}


h1, .text-xxl   { font-size: var(--text-xxl, 2.074em); }
h2, .text-xl    { font-size: var(--text-xl, 1.728em); }
h3, .text-lg    { font-size: var(--text-lg, 1.44em); }
h4, .text-md    { font-size: var(--text-md, 1.2em); }
.text-base      { font-size: --text-base-size; }
small, .text-sm { font-size: var(--text-sm, 0.833em); }
.text-xs        { font-size: var(--text-xs, 0.694em); }
BEM in 30 seconds
BEM (Blocks, Elements, Modifiers) is a naming methodology aimed at creating reusable components.

Here’s an example:

<header class="header">
  <a href="#0" class="header__logo"><!-- ... --></a>
  <nav class="header__nav">
    <ul>
      <li><a href="#0" class="header__link header__link--active">Homepage</a></li>
      <li><a href="#0" class="header__link">About</a></li>
      <li><a href="#0" class="header__link">Contact</a></li>
    </ul>
  </nav>
</header>
A block is a reusable component
An element is a child of the block (e.g., .block__element)
A modifier is a variation of a block/element (e.g., .block--modifier, .block__element--modifier).
Utility classes in 30 seconds
A utility class is a CSS class meant to do only one thing. For example:

<section class="padding-md">
  <h1>Title</h1>
  <p>Lorem ipsum dolor sit amet consectetur adipisicing elit.</p>
</section>


<style>
  .padding-sm { padding: 0.75em; }
  .padding-md { padding: 1.25em; }
  .padding-lg { padding: 2em; }
</style>
You can potentially build entire components out of utility classes:

<article class="padding-md bg radius-md shadow-md">
  <h1 class="text-lg color-contrast-higher">Title</h1>
  <p class="text-sm color-contrast-medium">Lorem ipsum dolor sit amet consectetur adipisicing elit.</p>
</article>
You can connect utility classes to CSS globals:

/* Spacing | Global */
:root {
  --space-unit: 1em;
  --space-xs:   calc(0.5 * var(--space-unit));
  --space-sm:   calc(0.75 * var(--space-unit));
  --space-md:   calc(1.25 * var(--space-unit));
  --space-lg:   calc(2 * var(--space-unit));
  --space-xl:   calc(3.25 * var(--space-unit));
}

/* responsive rule affecting all spacing variables */
@media (min-width: 64rem) {
  :root {
    --space-unit:  1.25em; /* 👇 this responsive decision affects all margins and paddings */
  }
}

/* margin and padding util classes - apply spacing variables */
.margin-xs { margin: var(--space-xs); }
.margin-sm { margin: var(--space-sm); }
.margin-md { margin: var(--space-md); }
.margin-lg { margin: var(--space-lg); }
.margin-xl { margin: var(--space-xl); }

.padding-xs { padding: var(--space-xs); }
.padding-sm { padding: var(--space-sm); }
.padding-md { padding: var(--space-md); }
.padding-lg { padding: var(--space-lg); }
.padding-xl { padding: var(--space-xl); }
A real-life example
Explaining a methodology using basic examples doesn’t bring up the real issues nor the advantages of the method itself.

Let’s build something together! 

We’ll create a gallery of card elements. First, we’ll do it using only the BEM approach, and we’ll point out the issues you may face by going BEM only. Next, we’ll see how Globals reduce the size of your CSS. Finally, we’ll make the component customizable introducing utility classes to the mix.

Here’s a look at the final result:


Let’s start this experiment by creating the gallery using only BEM:

<div class="grid">
  <article class="card">
    <a class="card__link" href="#0">
      <figure>
        <img class="card__img" src="/image.jpg" alt="Image description">
      </figure>


      <div class="card__content">
        <h1 class="card__title-wrapper"><span class="card__title">Title of the card</span></h1>


        <p class="card__description">Lorem ipsum dolor sit amet consectetur adipisicing elit. Tempore, totam?</p>
      </div>


      <div class="card__icon-wrapper" aria-hidden="true">
        <svg class="card__icon" viewBox="0 0 24 24"><!-- icon --></svg>
      </div>
    </a>
  </article>


  <article class="card"><!-- card --></article>
  <article class="card"><!-- card --></article>
  <article class="card"><!-- card --></article>
</div>
In this example, we have two components: .grid and .card. The first one is used to create the gallery layout. The second one is the card component.

First of all, let me point out the main advantages of using BEM: low specificity and scope.

/* without BEM */
.grid {}
.card {}
.card > a {}
.card img {}
.card-content {}
.card .title {}
.card .description {}


/* with BEM */
.grid {}
.card {}
.card__link {}
.card__img {}
.card__content {}
.card__title {}
.card__description {}
If you don’t use BEM (or a similar naming method), you end up creating inheritance relationships (.card > a).

/* without BEM */
.card > a.active {} /* high specificity */


/* without BEM, when things go really bad */
div.container main .card.is-featured > a.active {} /* good luck with that 😦 */


/* with BEM */
.card__link--active {} /* low specificity */
Dealing with inheritance and specificity in big projects is painful. That feeling when your CSS doesn’t seem to be working, and you find out it’s been overwritten by another class 😡! BEM, on the other hand, creates some kind of scope for your components and keeps specificity low.

But… there are two main downsides of using only BEM:

Naming too many things is frustrating
Minor customizations are not easy to do or maintain
In our example, to stylize the components, we’ve created the following classes:

.grid {}
.card {}
.card__link {}
.card__img {}
.card__content {}
.card__title-wrapper {}
.card__title {}
.card__description {}
.card__icon-wrapper {}
.card__icon {}
The number of classes is not the issue. The issue is coming up with so many meaningful names (and having all your teammates use the same naming criteria).

For example, imagine you have to modify the card component by including an additional, smaller paragraph:

<div class="card__content">
  <h1 class="card__title-wrapper"><span class="card__title">Title of the card</span></h1>
  <p class="card__description">Lorem ipsum dolor...</p>
  <p class="card__description card__description--small">Lorem ipsum dolor...</p> <!-- 👈 -->
</div>
How do you call it? You could consider it a variation of the .card__description element and go for .card__description .card__description--small. Or, you could create a new element, something like .card__small, .card__small-p, or .card__tag. See where I’m going? No one wants to spend time thinking about class names. BEM is great as long as you don’t have to name too many things.

The second issue is dealing with minor customizations. For example, imagine you have to create a variation of the card component where the text is center-aligned.

You’ll probably do something like this:

<div class="card__content card__content--center"> <!-- 👈 -->
  <h1 class="card__title-wrapper"><span class="card__title">Title of the card</span></h1>
  <p class="card__description">Lorem ipsum dolor sit amet consectetur adipisicing elit. Tempore, totam?</p>
</div>


<style>
  .card__content--center { text-align: center; }
</style>
One of your teammates, working on another component (.banner), is facing the same problem. They create a variation for their component as well:

<div class="banner banner--text-center"></div>


<style>
  .banner--text-center { text-align: center; }
</style>
Now imagine you have to include the banner component into a page. You need the variation where the text is aligned in the center. Without checking the CSS of the banner component, you may instinctively write something like banner banner--center in your HTML, because you always use --center when you create variations where the text is center-aligned. Not working! Your only option is to open the CSS file of the banner component, inspect the code, and find out what class should be applied to align the text in the center.

How long would it take, 5 minutes? Multiply 5 minutes by all the times this happens in a day, to you and all your teammates, and you realize how much time is wasted. Plus, adding new classes that do the same thing contributes to bloating your CSS.

CSS Globals and utility classes to the rescue
The first advantage of setting global styles is having a set of CSS rules that apply to all the components.

For example, if we set responsive rules in the spacing and typography globals, these rules will affect the grid and card components as well. In CodyFrame, we increase the body font size at a specific breakpoint; because we use “em” units for all margins and paddings, the whole spacing system is updated at once generating a cascade effect.


Spacing and typography responsive rules — no media queries on a component level 
As a consequence, in most cases, you won’t need to use media queries to increase the font size or the values of margins and paddings!

/* without globals */
.card { padding: 1em; }


@media (min-width: 48rem) {
  .card { padding: 2em; }
  .card__content { font-size: 1.25em; }
}


/* with globals (responsive rules intrinsically applied) */
.card { padding: var(--space-md); }
Not just that! You can use the globals to store behavioral components that can be combined with all other components. For example, in CodyFrame, we define a .text-component class that is used as a “text wrapper.” It takes care of line height, vertical spacing, basic styling, and other things.

If we go back to our card example, the .card__content element could be replaced with the following:

<!-- without globals -->
<div class="card__content">
  <h1 class="card__title-wrapper"><span class="card__title">Title of the card</span></h1>
  <p class="card__description">Lorem ipsum dolor sit amet consectetur adipisicing elit. Tempore, totam?</p>
</div>


<!-- with globals -->
<div class="text-component">
  <h1 class="text-lg"><span class="card__title">Title of the card</span></h1>
  <p>Lorem ipsum dolor sit amet consectetur adipisicing elit. Tempore, totam?</p>
</div>
The text component will take care of the text formatting, and make it consistent across all the text blocks in your project. Plus, we’ve already eliminated a couple of BEM classes.

Finally, let’s introduce the utility classes to the mix!
Utility classes are particularly useful if you want the ability to customize the component later on without having to check its CSS.

Here’s how the structure of the card component changes if we swap some BEM classes with utility classes:

<article class="card radius-lg">
  <a href="#0" class="block color-inherit text-decoration-none">
    <figure>
      <img class="block width-100%" src="image.jpg" alt="Image description">
    </figure>


    <div class="text-component padding-md">
      <h1 class="text-lg"><span class="card__title">Title of the card</span></h1>
      <p class="color-contrast-medium">Lorem ipsum dolor sit amet consectetur adipisicing elit. Tempore, totam?</p>
    </div>


    <div class="card__icon-wrapper" aria-hidden="true">
      <svg class="icon icon--sm color-white" viewBox="0 0 24 24"><!-- icon --></svg>
    </div>
  </a>
</article>
The number of BEM (component) classes has shrunk from 9 to 3:

.card {}
.card__title {}
.card__icon-wrapper {}
That means you won’t deal much with naming things. That said, we can’t avoid the naming issue entirely: even if you create Vue/React/SomeOtherFramework components out of utility classes, you still have to name the components.

All the other BEM classes have been replaced by utility classes. What if you have to make a card variation with a bigger title? Replace text-lg with text-xl. What if you want to change the icon color? Replace color-white with color-primary. How about aligning the text in the center? Add text-center to the text-component element. Less time thinking, more time doing!

Why don’t we just use utility classes?
Utility classes speed-up the design process and make it easier to customize things. So why don’t we forget about BEM and use only utility classes? Two main reasons:

By using BEM together with utility classes, the HTML is easier to read and customize.
Use BEM for:

DRY-ing the HTML from the CSS you don’t plan on customizing (e.g., behavioral CSS-like transitions, positioning, hover/focus effects),
advanced animations/effects.
Use utility classes for:

the “frequently-customized” properties, often used to create component variations (like padding, margin, text-alignment, etc.),
elements that are hard to identify with a new, meaningful class name (e.g., you need a parent element with a position: relative → create <div class="position-relative"><div class="my-component"></div></div>).
Example: 

<!-- use only Utility classes -->
<article class="position-relative overflow-hidden bg radius-lg transition-all duration-300 hover:shadow-md col-6@sm col-4@md">
  <!-- card content -->
</article>


<!-- use BEM + Utility classes -->
<article class="card radius-lg col-6@sm col-4@md">
  <!-- card content -->
</article>
For these reasons, we suggest that you don’t add the !important rule to your utility classes. Using utility classes doesn’t need to be like using a hammer. Do you think it would be beneficial to access and modify a CSS property in the HTML? Use a utility class. Do you need a bunch of rules that won’t need editing? Write them in your CSS. This process doesn’t need to be perfect the first time you do it: you can tweak the component later on if required. It may sound laborious “having to decide” but it’s quite straightforward when you put it to practice.

Utility classes are not your best ally when it comes to creating unique effects/animations.
Think about working with pseudo-elements, or crafting unique motion effects that require custom bezier curves. For those, you still need to open your CSS file.

Consider, for example, the animated background effect of the card we’ve designed. How hard would it be to create such an effect using utility classes?

The same goes for the icon animation, which requires animation keyframes to work:

.card:hover .card__title {
  background-size: 100% 100%;
}


.card:hover .card__icon-wrapper .icon {
  animation: card-icon-animation .3s;
}


.card__title {
  background-image: linear-gradient(transparent 50%, alpha(var(--color-primary), 0.2) 50%);
  background-repeat: no-repeat;
  background-position: left center;
  background-size: 0% 100%;
  transition: background .3s;
}


.card__icon-wrapper {
  position: absolute;
  top: 0;
  right: 0;
  width: 3em;
  height: 3em;
  background-color: alpha(var(--color-black), 0.85);
  border-bottom-left-radius: var(--radius-lg);
  display: flex;
  justify-content: center;
  align-items: center;
}


@keyframes card-icon-animation {
  0%, 100% {
    opacity: 1;
    transform: translateX(0%);
  }
  50% {
    opacity: 0;
    transform: translateX(100%);
  }
  51% {
    opacity: 0;
    transform: translateX(-100%);
  }
}
Final result
Here’s the final version of the cards gallery. It also includes grid utility classes to customize the layout.


File structure
Here’s how the structure of a project built using the method described in this article would look like:

project/
└── main/
    ├── assets/
    │   ├── css/
    │   │   ├── components/
    │   │   │   ├── _card.scss
    │   │   │   ├── _footer.scss
    │   │   │   └── _header.scss
    │   │   ├── globals/
    │   │   │   ├── _accessibility.scss
    │   │   │   ├── _breakpoints.scss
    │   │   │   ├── _buttons.scss
    │   │   │   ├── _colors.scss
    │   │   │   ├── _forms.scss
    │   │   │   ├── _grid-layout.scss
    │   │   │   ├── _icons.scss
    │   │   │   ├── _reset.scss
    │   │   │   ├── _spacing.scss
    │   │   │   ├── _typography.scss
    │   │   │   ├── _util.scss
    │   │   │   ├── _visibility.scss
    │   │   │   └── _z-index.scss
    │   │   ├── _globals.scss
    │   │   ├── style.css
    │   │   └── style.scss
    │   └── js/
    │       ├── components/
    │       │   └── _header.js
    │       └── util.js
    └── index.html
You can store the CSS (or SCSS) of each component into a separate file (and, optionally, use PostCSS plugins to compile each new /component/componentName.css file into style.css). Feel free to organize the globals as you prefer; you could also create a single globals.css file and avoid separating the globals in different files.

Conclusion
Working on large-scale projects requires a solid architecture if you want to open your files months later and don’t get lost. There are many methods out there that tackle this issue (CSS-in-JS, utility-first, atomic design, etc.).

The method I’ve shared with you today relies on creating crosswise rules (globals), using utility classes for rapid development, and BEM for modular (behavioral) classes.

You can learn in more detail about this method on CodyHouse. Any feedback is welcome!

BEM Methodology In CSS: A Quick Start Guide
January 14, 2020

This is a quick start guide to learning BEM, the component-driven CSS methodology.

If you want to start practicing and applying BEM to your projects, this guide will help you get started.

Bonus: Download a free cheat sheet that will show you how to quickly get started with BEM.

Ready? Let’s dive in:

BEM overview
B - Blocks
E - Elements
M - Modifiers
BEM Overview
BEM (Block-Element-Modifier) is a CSS naming convention developed by the team at Yandex to improve scalability and maintainability in web development.

Put simply, the idea of BEM is to “divide the user interface into independent blocks” by naming CSS classes in the following methodology:

/* Block component */
.card {}
/* Elements are dependent on their parent block */ 
.card__img {}
/* Modifiers are for incremental style changes */
.card--dark {} 
.card__img--large {}
Block: an independent component that can be reused (e.g. with class name .nav)
Element: a child within a block that cannot be used separately from that block (e.g. with class name .nav__item)
Modifier: a variation in the style of either a block or modifier (e.g. with class name .nav--dark)
Let’s dive into some real CSS examples to get a hang of this thing.

Blocks
Blocks are reusable components. Like buttons, cards or form fields.

When naming your blocks, focus on describing its purpose (i.e. what it is) rather than its state (i.e. what it looks like).

For example, .btn or .nav follows the correct naming convention for a block.

.big or .bright-pink describes how it looks, so doesn’t scale well when you want to change the design later on.

<!-- INCORRECT -->
<div class="large-red-box">
 <img src="...">
 <h2>...</h2>
 <p>...</p>
 <a>...</a>
</div>
<style>
 .large-red-box {}
</style>
<!-- CORRECT -->
<div class="card">
 <img src="...">
 <h2>...</h2>
 <p>...</p>
 <a>...</a>
</div>
<style>
 .card {}
</style>
If you’re wondering how to place blocks within blocks (for example, a button inside a nav), here’s a short article to help you with that.

Elements
Inside blocks are where elements live. Elements are dependent on their parent block, and so cannot be used without them.

Elements also have a unique CSS class naming convention which works like this:

.block__element

For example, using the .card component, an element inside the card component (like an image) would have a class name like .card__img.

The element name always appends the block name, separated by a double underscore __.

<!-- INCORRECT -->
<div class="card">
 <img src="...">
 <h2>...</h2>
 <p>...</p>
 <a>...</a>
</div>
<style>
 .card {}
 .card img {}
 .card h2 {}
 .card p {}
 .card a {}
</style>
<!-- CORRECT -->
<div class="card">
 <img class="card__img" src="...">
 <h2 class="card__title" >...</h2>
 <p class="card__description" >...</p>
 <a class="card__button">...</a>
</div>
<style>
 .card {}
 .card__img {}
 .card__title {}
 .card__description {}
</style>
It’s important to note that the second code snippet avoids using more than 1 selector to target the styles (e.g. like .card img {}).

It’s considered best practice to use a BEM element class and use that directly instead (like .card__img {}).

Following this approach reduces the chance of cascade issues down the line.

If you’re wondering on how to handle BEM elements that are nested 3 or 4 layers deep, check out this article on the topic.

Modifiers
When you have varying styles in blocks (or elements), that’s where modifiers come in.

For example, your ‘card’ block might have a light and dark version. Or you might have primary and secondary buttons.

Modifiers have a unique CSS naming convention which works like this:

block--modifier or block__element--modifier.

That’s right- BEM modifiers can be applied to both blocks and elements.

Let’s dive into some bad and good practices:

<!-- INCORRECT -->
<div class="card--dark">
 <img src="...">
 <h2 class="card__title--large">...</h2>
 <p>...</p>
 <a>...</a>
</div>
<style>
 .card--dark {}
 .card__title--large {}
</style>
It’s considered bad practice to use a modifier class in isolation (i.e. without the block or element class).

That’s because the modifier is meant to add incremental style changes to the block.

Therefore, whenever using a modifier, ensure it’s used with the base class:

<!-- CORRECT -->
<div class="card card--dark">
 <img src="...">
 <h2 class="card__title card__title--large">...</h2>
 <p>...</p>
 <a>...</a>
</div>
<style>
 .card {}
 .card--dark {}
 .card__title {}
 .card__title--large {}
</style>
And that’s it!

Those are the fundamentals to get you off and running with BEM.

If you’re interested to learn more about the ‘why’ behind BEM, I recommend checking out this CSS Tricks article.

Like learning anything new, practicing is key. Give BEM a shot in your next project and see where it takes you!

Want to become an advanced CSS & Sass developer?
Levelling up your CSS & Sass skills in 2021 is a great idea. Here's why:

Increase your employability and value as a front-end developer
Learn how to style your websites and applications in clean, efficient code
Use tooling and techniques like BEM, flexbox, grid & more to improve your code

BEM in SCSS - A Complete Small Guide
Published:
Jul 28, 2024
A Complete Small Guide to BEM in SCSS
BEM (Block, Element, Modifier) is a popular methodology for writing maintainable and scalable CSS. This guide will walk you through the principles of BEM, how to implement it in SCSS, and the best practices to follow, updated for 2024.

What is BEM?#
BEM is a naming convention for CSS classes that aims to make the code more readable and easier to maintain. It divides the user interface into independent blocks, elements, and modifiers.

Block: A standalone component that is meaningful on its own (e.g., button).
Element: A part of a block that has no standalone meaning and is semantically tied to its block (e.g., button__icon).
Modifier: A flag on a block or element that changes its appearance or behavior (e.g., button--primary).
Key Benefits of BEM#
Reusability: BEM promotes reusability of components by keeping them independent.
Scalability: Helps in maintaining large codebases by providing a clear structure.
Readability: Enhances readability with a consistent naming convention.
Maintainability: Simplifies maintenance by organizing CSS in a modular fashion.
Implementing BEM in SCSS#
Basic Structure#
Here is how you can structure your SCSS using BEM:

/* Block */
.button {
  // Block styles
}

/* Element */
.button__icon {
  // Element styles
}

/* Modifier */
.button--primary {
  // Modifier styles
}
Copy
Nested Structure in SCSS#
SCSS allows nesting, which can be used to maintain a clear hierarchy of styles:

.button {
  padding: 10px;
  border: none;
  cursor: pointer;

  &__icon {
    margin-right: 5px;
  }

  &--primary {
    background-color: blue;
    color: white;
  }

  &--secondary {
    background-color: gray;
    color: black;
  }
}
Copy
Example: Button Component#
Let’s create a button component using BEM in SCSS:

.button {
  display: inline-flex;
  align-items: center;
  padding: 8px 16px;
  border: 1px solid transparent;
  border-radius: 4px;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s;

  &__icon {
    margin-right: 8px;
  }

  &--primary {
    background-color: #007bff;
    color: #fff;

    &:hover {
      background-color: #0056b3;
    }
  }

  &--secondary {
    background-color: #6c757d;
    color: #fff;

    &:hover {
      background-color: #5a6268;
    }
  }
}
Copy
HTML Structure#
The corresponding HTML for the button component would look like this:

<button class="button button--primary">
  <span class="button__icon">🔍</span>
  Search
</button>
Copy
Best Practices for Using BEM in SCSS#
Consistent Naming: Follow the BEM naming convention consistently across your project.
Avoid Deep Nesting: Limit nesting in SCSS to maintain readability and performance.
Keep It Simple: Use BEM to simplify your CSS structure, not complicate it.
Use Variables and Mixins: Leverage SCSS features like variables and mixins for reusable styles.
Document Your Code: Comment your code to explain the purpose of blocks, elements, and modifiers.
Conclusion#
BEM combined with SCSS provides a powerful way to write scalable and maintainable CSS. By following the BEM methodology, you can create a clear and organized CSS structure that enhances readability and maintainability. Embrace BEM in SCSS to improve the quality of your web development projects in 2024 and beyond.

Stay updated with the latest practices and standards to ensure your CSS remains efficient and effective.

Introduction to BEM Methodology
When building smaller websites, the way developers structure their CSS code is usually not a big issue. However, when it comes to larger, more complex projects, code organization becomes crucial.

In this article, Toptal Freelance Software Engineer Tomislav Matijević introduces us to BEM methodology and explains how this CSS practice can massively improve code maintainability, speed up the development process, and streamline the teamwork of developers by arranging CSS classes into independent modules.

authors are vetted experts in their fields and write on topics in which they have demonstrated experience. All of our content is peer reviewed and validated by Toptal experts in the same field.
Introduction to BEM Methodology
Tomislav Matijević
View full profile
By
Tomislav Matijević
Verified Expert 
in Engineering
Tomislav is a software engineer well versed in front-end technologies, particularly in vanilla JavaScript and React.js.

Expertise

CSS
Front-end
Previously At

Netgen

Share this article
What Is BEM Methodology?
When you are building smaller websites, how you organize your styles is usually not a big problem. You create your usual files, write all the needed CSS, and that’s all. However, when it comes to larger, more complex projects, how you organize your code becomes crucial. How the code is structured is even more important if you are working in a team consisting of multiple front-end and back-end developers.

BEM Methodology will massively improve code maintainability and speed up the development process
BEM Methodology will massively improve code maintainability and speed up the development process
Tweet
Today, there are plenty of methodologies with the aim of reducing CSS code and making your CSS code more maintainable. In this article, I am going to explain and provide a few examples of one of them: BEM. BEM stands for Block Element Modifier. The main idea behind it is to speed up the development process, and ease the teamwork of developers by arranging CSS classes into independent modules. If you ever saw a class name like header__form--search, that is BEM in action. Yes, classes can be named very long, but they are all readable and understandable.

Note that the best practice is to use BEM only with classes, and not IDs because classes allow you to repeat names if necessary and create more consistent coding structure. Also, if you want to break your website into organized modules, it should consist of the same structure: block, element, and modifier. Where each block can have multiple elements, and both block and elements can have multiple modifiers. However, let’s first start with the basic BEM structure and explain it with examples.

Block
A block represents an object in your website. Think of it as bigger structural chunks of your code. Most common blocks on every website today are header, content, sidebar, footer, and search. Blocks in BEM are always a starting point of chaining your CSS classes on to. Take a look at a few block examples:

a content
a menu
a search form
.content {/* Styles */}
.menu {/* Styles */}
.search {/* Styles */}
Element
An element is a component within the block that performs a particular function. It should only make sense in the context of its block:

a content article
a menu item
a search input field
.content__article {/* Styles */}
.menu__item {/* Styles */}
.search__input {/* Styles */}
Modifier
A modifier is how we represent the variations of a block. If you’ve ever used Bootstrap, then the best example would be the button sizes. Button sizes are just size variations of the button itself, which makes it the modifier:

a content featured article
a menu link
a search field with or without icon
.content__article--featured {/* Styles */}
.menu__item--link {/* Styles */}
.search__input--icon {/* Styles */}
Naming Conventions
The primary purpose of BEM methodology is to make names of CSS selectors as informative and transparent as possible. Original BEM style is defined in this way:

Block name is usually a single word like .header, but if you have longer block definition then it is divided with a single hyphen -:

.lang-switcher {/* Styles */}
Element name starts with double underscore __:

.lang-switcher__flag {/* Styles */}
Modifier name starts with single underscore _:

.lang-switcher__flag_basic {/* Styles */}
There is only one very critical rule in BEM methodology - a modifier cannot be used outside of the context of its owner.

Example:

.btn_big {/* Styles */}
You can use btn_big only if header is defined also.

Bad example:

<div class=”btn_big”>...</div>
Good example:

<div class=”btn btn_big”>...</div>
Beside these original BEM styles, there are alternative naming schemes like Harry Roberts and CamelCase styles.

Harry Roberts style example:

.block-name__element-name--modifier-name {/* Styles */}
CamelCase style example:

.BlockName__ElementName_ModifierName {/* Styles */}
There are few others too, but these two are the most common ones. Personally, I am a fan of the naming convention proposed by Harris Roberts, which has the following rules:

Names are written in lowercase
Words within the names of BEM entities are separated by a hyphen -
An element name is separated from a block name by a double underscore __
Boolean modifiers are delimited by double hyphens --
Key-value type modifiers are not used
The reason why this naming convention is much better formed than others is that you can easily distinguish modifier element from others. In original naming conventions, modifier would be defined like this:

.block__element_modifier {/* Styles */}
But as you can see, there is not very much difference between a single and double underscore. On the other hand, double hyphen provides clean separation, and you can see the modifier instantly:

.block__element--modifier {/* Styles */}
BEM Example in Different Formats
Please note that besides CSS, BEM is also very useful in organizing your JSON, XML, tree files, or any format supports nesting. Think of BEM methodology as a good way to build your UI.

HTML structured in BEM format
Let’s consider the following HTML, structured in BEM format:

<header class=”header”>
  <img class=”header__logo”>
  <form class=”header__search-from”>
    <input class=”header__search-from__input” type=”input”>
    <button class=”header__search-from__button” type=”button”>
  </form>
  <div class=”header__lang-switcher”></div>
</header>
The same can be achieved using JSON and XML format.

XML:

<block:header>
  <block:logo/>
  <block:search-from>
    <block:input/>
    <block:button/>
  </block>
  <block:lang-switcher/>
</block>
JSON:

{
  block: ‘header’,
  content: [
    { block: ‘logo’ },
    {
      block: ‘search-form’,
      content: [
        { block: ‘input’ },
        { block: ‘button’ }
      ]
    },
    { block: ‘lang-switcher’ }
  ]
}
File System Organization of a BEM Project
In BEM, it is critical to organize your files in a correct manner. Not only is BEM providing you a great organization of CSS classes and making them completely understandable, but also gives you a very maintainable file structure. Let’s take an example project, using BEM file organization technique with SASS files:

blocks/
  input/
    __box/
      --big/
        input__box--big.scss
      input__box.scss
  button/
    --big/
      button--big.scss
As you can see above, just by seeing the subfolder structure inside your main folder, everything is clear and organized. In this way, it makes no difference who is working after you or if you are working after someone, because it is incredibly easy to follow the same pattern.

Dividing BEM Project into Platforms
Besides just organizing your files using BEM methodology techniques, you can also go into more specific things. For example, if you are building a web project which is going to be fully responsive, and the client specified that some blocks on the mobile are totally different than on desktop devices, it would be best to divide your BEM folder structure into platforms. Example of organizing buttons on various platforms:

common.blocks/
  button/
    button.scss
desktop.blocks/
  button/
    buttons.scss
mobile.blocks/
  button/
    button.scss
Note that this is just an example if you want to organize your whole project using BEM methodology. File tree with BEM structure is not mandatory to use BEM correctly, you can use BEM just in some segments of the project. So far I haven’t been using this strict BEM file structure organization where every element and modifier has its file created. Instead, I am just creating a file structure for blocks which are having a declaration of its elements and modifiers.

Tree Organization of a BEM Project
BEM in Practice
Since you are now familiar with naming conventions, I will demonstrate BEM methodology in practice. Let’s say that we have this HTML code in action:

<a class=”btn btn--big btn--primary-color” href=”#” title=”Title”>
  <span class=”btn__price”>$3.99</span>
  <span class=”btn__text”>Product</span>
</a>
With the following CSS markup applied:

.btn__price {/* Styles */}

.btn__text {/* Styles */}

.btn--big {/* Styles */}

.btn--primary-color {/* Styles */}
Now, don’t be mislead. In our examples so far we almost always had a block, element, and modifier, which doesn’t always have to be the case.

For example, let’s say we have a block named person. A person has legs and hands, it can also be female or male. If we want to define a male person with a right hand it will look like this:

.person--male__hand--right {/* Styles */}
Now you can see the real meaning of the BEM. We defined a person which modifier is a gender. Since it doesn’t matter if a person is male or female, it has a hand, and hand is an element. And again, each person can have right or left hand which is again a modifier.

In another case, if we want to define general person with a single hand, we will do it like this:

.person__hand {/* Styles */}
As you can notice, once you get comfortable with BEM it’s very easy to structure your CSS and HTML structure with it.

Using BEM with CSS Preprocessors
Personally, I can not imagine starting any new project without using one of the CSS preprocessors. As you all know, preprocessors are a great thing and they are providing us a lot of benefits, and most importantly they are a perfect match with BEM methodology.

Related: Embracing Sass: Why You Should Stop Using Vanilla CSS
In the following example, you can see the most typical example of BEM, in combination with SASS:

.person {
  &__hand {/* Styles */}

  &__leg {/* Styles */}

  &--male {
    /* Styles */

    &__hand {
      /* Styles */

      &--left {/* Styles */}

      &--right {/* Styles */}
    }

    &__leg {
      /* Styles */

      &--left {/* Styles */}

      &--right {/* Styles */}
    }
  }

  &--female {
    /* Styles */

    &__hand {
      /* Styles */

      &--left {/* Styles */}

      &--right {/* Styles */}
    }

    &__leg {
      /* Styles */

      &--left {/* Styles */}

      &--right {/* Styles */}
    }
  }
}
SASS code will compile into the following CSS:

.person__hand {/* Styles */}

.person__leg {/* Styles */}

.person--male {/* Styles */}

.person--male__hand {/* Styles */}

.person--male__hand--left {/* Styles */}

.person--male__hand--right {/* Styles */}

.person--male__leg {/* Styles */}

.person--male__leg--left {/* Styles */}

.person--male__leg--right {/* Styles */}

.person--female {/* Styles */}

.person--female__hand {/* Styles */}

.person--female__hand--left {/* Styles */}

.person--female__hand--right {/* Styles */}

.person--female__leg {/* Styles */}

.person--female__leg--left {/* Styles */}

.person--female__leg--right {/* Styles */}
If you want to go even further, you can use a handy SASS mixins for BEM:

/// Block Element
/// @param {String} $element - Element's name
@mixin element($element) {
    &__#{$element} {
        @content;
    }
}

/// Block Modifier
/// @param {String} $modifier - Modifier's name
@mixin modifier($modifier) {
    &--#{$modifier} {
        @content;
    }
}
And you can use it like this:

.person {
  @include element('hand') {/* Person hand */}

  @include element('leg') {/* Person leg */}

  @include modifier('male') {
    /* Person male */
    
    @include element('hand') {
      /* Person male hand */
      @include modifier('left') {
        /* Person male left hand */
      }
      @include modifier('right') {
        /* Person male right hand */
      }
    }
  }
}
Which will produce the following CSS output:

.person__hand {
  /* Person hand */
}

.person__leg {
  /* Person leg */
}

.person--male {
  /* Person male */
}

.person--male__hand {
  /* Person male hand */
}

.person--male__hand--left {
  /* Person male left hand */
}

.person--male__hand--right {
  /* Person male right hand */
}
I know that most likely you won’t have a use case this long, but this is a great example of how BEM is used and why it’s so powerful, both in small and large scale projects.

Starting Your BEM Project
As explained in the official BEM documentation, the easiest way to start you own new BEM project is to use existing GIT repository. Simply use Git clone command:

$ git clone https://github.com/bem/project-stub.git
Next, go to a newly created directory and install all dependencies:

$ npm install
All required dependencies will be installed:

BEM dependencies
Build the project using ENB:

$ node_modules/.bin/enb make
Run a server mode for development:

$ node_modules/.bin/enb server
As a result, the following message appears:

Server started at 0.0.0.0:8080
Now, this means that the server is up and running. You can now check the results on this address:

http://localhost:8080/desktop.bundles/index/index.html
As you can see, there are a lot of elements already created which are defined inside bemjson file which is located here:

project-stub/desktop.bundles/index/index.bemjson.js
You can see and explore the current structure of the file that is generating all that HTML, which you see at your localhost index.html file. We are going to alter this file to get our “Person” BEM project which we explained in a previous chapter. You can remove (or comment) the whole code from index.bemjson.js file, and replace it with this one:

module.exports = {
    block: 'page',
    title: 'Person BEM',
    favicon : '/favicon.ico',
    head : [
        { elem : 'meta', attrs : { name : 'description', content : '' } },
        { elem : 'meta', attrs : { name : 'viewport', content : 'width=device-width, initial-scale=1' } },
        { elem : 'css', url : 'index.min.css' }
    ],
    scripts: [{ elem : 'js', url : 'index.min.js' }],
    content: [
        {
            block: 'person',
            content: [
                {
                    elem: 'male',
                    content: [
                        {
                            elem: 'leg',
                            mods: {side: 'left'},
                            content: 'Male person leg -- left'
                        },
                        {
                            elem: 'leg',
                            mods: {side: 'right'},
                            content: 'Male person leg -- right'
                        },
                        {
                            elem: 'hand',
                            mods: {side: 'left'},
                            content: 'Male person hand -- left'
                        },
                        {
                            elem: 'hand',
                            mods: {side: 'right'},
                            content: 'Male person hand -- right'
                        }
                    ]
                },
                {
                    elem: 'female',
                    content: [
                        {
                            elem: 'leg',
                            mods: {side: 'left'},
                            content: 'Female person leg -- left'
                        },
                        {
                            elem: 'leg',
                            mods: {side: 'right'},
                            content: 'Female person leg -- right'
                        },
                        {
                            elem: 'hand',
                            mods: {side: 'left'},
                            content: 'Female person hand -- left'
                        },
                        {
                            elem: 'hand',
                            mods: {side: 'right'},
                            content: 'Female person hand -- right'
                        }
                    ]
                },
            ]
        }
    ]
};
Now, the following HTML will be generated:

<div class="person">
    <div class="person__male">
        <div class="person__leg person__leg_side_left">
          Male person leg -- left
        </div>

        <div class="person__leg person__leg_side_right">
          Male person leg -- right
        </div>

        <div class="person__hand person__hand_side_left">
          Male person hand -- left
        </div>

        <div class="person__hand person__hand_side_right">
          Male person hand -- right
        </div>
    </div>

    <div class="person__female">
        <div class="person__leg person__leg_side_left">
          Female person leg -- left
        </div>

        <div class="person__leg person__leg_side_right">
          Female person leg -- right
        </div>

        <div class="person__hand person__hand_side_left">
          Female person hand -- left
        </div>

        <div class="person__hand person__hand_side_right">
          Female person hand -- right
        </div>
    </div>
</div>
As you can see from the code above, the default BEM coding scheme was used in this scenario since we are just using default settings which BEM provided to us. There are a lot more commands and options which you can explore and use, such as creating new pages, blocks, or modifying BEM HTML. I will not go too deep into this, and it can all be found in the official BEM documentation.

BEM Advantages and Concerns
Advantages and Concerns
Advantages
BEM is excellent for maintaining. How many times have you had to work after someone on a large scaled project and you are just too afraid to change anything without something unknown collapsing? When using BEM, you know the exact purpose of the element and in which block it may appear.
Class names are logical and intuitive, and every member of the team knows what that element does on the website. BEM gives everyone on a project a declarative syntax they can share so they’re on the same page.
BEM eliminates nested CSS selectors. Every single HTML element has its own CSS class, and by its name you know what its purpose is. One selector to rule them all.
Concerns and Common Mistakes
Do not go too deep into nesting. The main rule should be not to use more than two levels of parent and child.
Be careful with where you start your block scope. A common mistake here is when a developer is using block, but he is not realising that at the later point of development that same block will have main parent block which will possibly break the rule with nesting.
Avoid SASS @extend. To quote Harry Roberts on this:
You can create a greater number of combinations in the view by not ‘tying’ classes together in Sass. The HTML has a much better paper trail in that you can see every class acting on a piece of the DOM. Your CSS stays much slimmer in that you don’t have to create new placeholder classes (or the manifest classes that combine them) every time you want to create a new piece of UI.

Conclusion
When I saw BEM coding scheme for the first time, my first thought was:

These classes are just too long to write and read.

But after giving it a try, now I can not imagine starting a new project without using it. For me, BEM massively improved my code maintainability, and I can for sure say that every developer who is going to be “thrown” into the BEM-based project will catch up really quickly with the whole code structure.

Despite all this, there’s a lot of discussion on social networks about BEM. Some say BEM isn’t good, wondering why they should write such long name classes instead of just use default HTML nested elements. Well, no one says that you must like BEM, but the fact is that the majority of front-end developers embrace it and find it extraordinary useful.